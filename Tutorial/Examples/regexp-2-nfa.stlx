regexp2NFA := procedure(r) {
    match (r) {
        case c | isString(c): 
             return genCharNFA(c);
        case Cat(r1, r2): 
             return catenate(regexp2NFA(r1), regexp2NFA(r2));        
        case Or(r1, r2): 
             return disjunction(regexp2NFA(r1), regexp2NFA(r2));
        case Star(r0): 
             return kleene(regexp2NFA(r0));
    }
};

genCharNFA := procedure(c) {
    q0 := getNewState();
    q1 := getNewState();
    delta := procedure(q, d) { 
                 if (q == q0 && d == c) { 
                     return { q1 };
                 } else { 
                     return {};
                 }
             };
    return [ {q0, q1}, delta, q0, q1 ];
};

catenate := procedure(f1, f2) {
    [m1, delta1, q1, q2] := f1;
    [m2, delta2, q3, q4] := f2;
    delta := procedure(q, c) {
                 if (q == q2 && c == "") {
                     return { q3 };
                 } else if (q in m1) {
                     return delta1(q, c);
                 } else if (q in m2) {
                     return delta2(q, c);
                 } else {
                     return {};
                 }
             };
    return [ m1 + m2, delta, q1, q4 ];
};

disjunction := procedure(f1, f2) {
    [m1, delta1, q1, q3] := f1;
    [m2, delta2, q2, q4] := f2;
    q0 := getNewState(); 
    q5 := getNewState(); 
    delta := procedure(q, c) {
                 if (q == q0 && c == "") {
                     return { q1, q2 };
                 } else if (q in { q3, q4 } && c == "") {
                     return { q5 };
                 } else if (q in m1) {
                     return delta1(q, c);
                 } else if (q in m2) {
                     return delta2(q, c);
                 } else {
                     return {};
                 } 
             };
    return [ { q0, q5 } + m1 + m2, delta, q0, q5 ];
};

kleene := procedure(f) {
    [m, delta0, q1, q2] := f;
    q0 := getNewState(); 
    q3 := getNewState(); 
    delta := procedure(q, c) {
                 if (q == q0 && c == "") {
                     return { q1, q3 };
                 } else if (q == q2 && c == "") {
                     return { q1, q3 };
                 } else if (q in m) {
                     return delta0(q, c);
                 } else {
                     return {};
                 } 
             };
    return [ { q0, q3 } + m, delta, q0, q3 ];
};

var gStateCount;
gStateCount := -1;

getNewState := procedure() {
    gStateCount += 1;
    return "q" + gStateCount;
};


