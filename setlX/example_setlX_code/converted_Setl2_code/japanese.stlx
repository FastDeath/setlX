
erlaubt := procedure(s, all) {
	return ( ! (verboten(s)) ) && ( ! (verboten(all - s)) );
};

verboten := procedure(s) {
	return ("Osama" in s && #s > 1 && ( ! ("George" in s) )) || ("Anton" in s && "Mama" in s && ( ! ("Papa" in s) )) || ("Bruno" in s && "Mama" in s && ( ! ("Papa" in s) )) || ("Cindy" in s && "Papa" in s && ( ! ("Mama" in s) )) || ("Doris" in s && "Papa" in s && ( ! ("Mama" in s) ));
};

bootOK := procedure(b) {
	return "Boot" in b && #b <= 3 && ("Mama" in b || "Papa" in b || "George" in b);
};

reachable := procedure(x, y, r) {
	p := {[x]};
	while (true) {
		old_P := p;
		p := p + path_product(p, r);
		found := {p in p | p(#p) == y};
		if (found != {}) {
			return arb(found);
		}
		if (p == old_P) {
			return;
		}
	}
};

path_product := procedure(p, q) {
	return {add(p, q): p in p, q in q | p(#p) == q(1) && ( ! (cyclic(add(p, q))) )};
};

cyclic := procedure(p) {
	return #{x: x in p} < #p;
};

add := procedure(p, q) {
	return p + q(2..);
};

all := {"George", "Osama", "Mama", "Papa", "Anton", "Bruno", "Cindy", "Doris", "Boot"};
p := pow(all);
r1 := {[s, s - b]: s in p, b in pow(s) | bootOK(b) && erlaubt(s - b, all)};
r2 := {[s - b, s]: s in p, b in pow(s) | bootOK(b) && erlaubt(s, all)};
r := r1 + r2;
start := all;
goal := {};
path := reachable(start, goal, r);
for (i in [1 .. #path]) {
	left := path(i);
	right := all - left;
	print(left - {"Boot"}, 20 * " ", right - {"Boot"});
	print();
	if (i == #path) {
		break;
	}
	if ("Boot" in left) {
		m := left - path(i + 1) - {"Boot"};
		print("    >>>> ", m, " >>>> ");
	} else {
		m := right - (all - path(i + 1)) - {"Boot"};
		print("    <<<< ", m, " <<<< ");
	}
	print();
}

