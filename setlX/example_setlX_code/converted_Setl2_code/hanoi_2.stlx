
lastChars := procedure(x, n) {
	s := str((x));
	m := n - #s;
	return m * " " + s;
};

partition := procedure(S1, S2, S3, All) {
	test := {S1, S2, S3} <= pow(All);
	test2 := forall(x in All | (x in S1 && x notin S2 + S3) || (x in S2 && x notin S1 + S3) || (x in S3 && x notin S1 + S2));
	test3 := forall(k in {S1, S2, S3}, l in {S1, S2, S3} | k * l == {} || k == l);
	return test && test2 && test3;
};

movePossible := procedure(Source, Target) {
	return Target == {} || (min/ Source < min/ Target);
};

oneStep := procedure(PS, R) {
	return {p + [z]: p in PS, [y, z] in R | p(#p) == y};
};

eliminateCycles := procedure(PS) {
	return {p in PS | ! (cyclic(p))};
};

cyclic := procedure(p) {
	return #{x: x in p} < #p;
};

reachable := procedure(x, y, R) {
	PS := {[x]};
	while (true) {
		old_PS := PS;
		PS := PS + eliminateCycles(oneStep(PS, R));
		P := {p in PS | p(#p) == y};
		if (P != {}) {
			return arb(P);
		}
		if (old_PS == PS) {
			return;
		}
	}
};

All := {1, 2, 3};
P := {[L1, L2, L3]: L1 in pow(All), L2 in pow(All), L3 in pow(All) | partition(L1, L2, L3, All)};
R12 := {[[L1, L2, L3], [L1 - {x}, L2 + {x}, L3]]: [L1, L2, L3] in P, x in {min/ L1} | movePossible(L1, L2)};
R21 := {[[L1, L2, L3], [L1 + {x}, L2 - {x}, L3]]: [L1, L2, L3] in P, x in {min/ L2} | movePossible(L2, L1)};
R13 := {[[L1, L2, L3], [L1 - {x}, L2, L3 + {x}]]: [L1, L2, L3] in P, x in {min/ L1} | movePossible(L1, L3)};
R31 := {[[L1, L2, L3], [L1 + {x}, L2, L3 - {x}]]: [L1, L2, L3] in P, x in {min/ L3} | movePossible(L3, L1)};
R23 := {[[L1, L2, L3], [L1, L2 - {x}, L3 + {x}]]: [L1, L2, L3] in P, x in {min/ L2} | movePossible(L2, L3)};
R32 := {[[L1, L2, L3], [L1, L2 + {x}, L3 - {x}]]: [L1, L2, L3] in P, x in {min/ L3} | movePossible(L3, L2)};
R := R12 + R21 + R31 + R13 + R23 + R32;
start := [{1, 2, 3}, {}, {}];
goal := [{}, {}, {1, 2, 3}];
path := reachable(start, goal, R);
print("\nLï¿½sung:");
for (i in [1 .. #path]) {
	t1 := lastChars(path(i)(1), 20);
	t2 := lastChars(path(i)(2), 20);
	t3 := lastChars(path(i)(3), 20);
	print(t1, t2, t3);
}

