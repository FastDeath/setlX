
verboten := procedure(s) {
	linksVerboten := ("Papa" in s && ("Cindy" in s || "Doris" in s) && ( ! (("Mama" in s)) )) || ("Mama" in s && ("Anton" in s || "Bruno" in s) && ( ! (("Papa" in s)) )) || ("Osama" in s && (( ! ("George" in s) )) && #s >= 2);
	rechtsVerboten := ("Papa" notin s && ("Cindy" notin s || "Doris" notin s) && ( ! (("Mama" notin s)) )) || ("Mama" notin s && ("Anton" notin s || "Bruno" notin s) && ( ! (("Papa" notin s)) )) || ("Osama" notin s && (( ! ("George" notin s) )) && (9 - #s) >= 2);
	return linksVerboten || rechtsVerboten;
};

bootOK := procedure(b) {
	return ("Boot" in b && #b in {2, 3} && ("Papa" in b || "Mama" in b || "George" in b));
};

reachable := procedure(x, y, r) {
	p := {[x]};
	while (true) {
		old_P := p;
		p := p + path_product(p, r);
		found := {p in p | p(#p) == y};
		if (found != {}) {
			return arb(found);
		}
		if (p == old_P) {
			return;
		}
	}
};

path_product := procedure(p, q) {
	return {add(p, q): p in p, q in q | p(#p) == q(1) && ( ! (cyclic(add(p, q))) )};
};

cyclic := procedure(p) {
	return #{x: x in p} < #p;
};

add := procedure(p, q) {
	return p + q(2..);
};

all := {"George", "Osama", "Mama", "Papa", "Anton", "Bruno", "Cindy", "Doris", "Boot"};
p := pow(all);
r1 := {[s, s - b]: s in p, b in pow(s) | ( ! (verboten(s)) ) && ( ! (verboten(s - b)) ) && bootOK(b)};
r2 := {[s, s + b]: s in p, b in pow((all - s)) | ( ! (verboten(s)) ) && ( ! (verboten(s + b)) ) && bootOK(b)};
r := r1 + r2;
start := all;
goal := {};
path := reachable(start, goal, r);
for (i in [1 .. #path]) {
	left := path(i);
	right := all - left;
	print(left - {"Boot"}, 20 * " ", right - {"Boot"});
	print();
	if (i == #path) {
		break;
	}
	if ("Boot" in left) {
		m := left - path(i + 1) - {"Boot"};
		print("    >>>> ", m, " >>>> ");
	} else {
		m := right - (all - path(i + 1)) - {"Boot"};
		print("    <<<< ", m, " <<<< ");
	}
	print();
}

