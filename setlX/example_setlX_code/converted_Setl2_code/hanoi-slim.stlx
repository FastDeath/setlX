
relation := procedure(P, i, j) {
	return {[A, move(A, i, j)]: A in P | movePossible(A(i), A(j))};
};

move := procedure(Triple, i, j) {
	Result := Triple;
	Result(i) := Triple(i) - {min(Triple(i))};
	Result(j) := Triple(j) + {min(Triple(i))};
	return Result;
};

partition := procedure(S1, S2, S3, All) {
	return S1 + S2 + S3 == All && #S1 + #S2 + #S3 == #All;
};

movePossible := procedure(Source, Target) {
	return min(Source + {4}) < min(Target + {4});
};

printPath := procedure(path) {
	for (i in [1 .. #path]) {
		t1 := lastChars(path(i)(1), 20);
		t2 := lastChars(path(i)(2), 20);
		t3 := lastChars(path(i)(3), 20);
		print(t1, t2, t3);
	}
};

lastChars := procedure(x, n) {
	s := str((x));
	m := n - #s;
	return m * " " + s;
};

oneStep := procedure(PS, R) {
	return {p + [z]: p in PS, [y, z] in R | p(#p) == y};
};

eliminateCycles := procedure(PS) {
	return {p in PS | ( ! (cyclic(p)) )};
};

cyclic := procedure(p) {
	return #{x: x in p} < #p;
};

reachable := procedure(x, y, R) {
	PS := {[x]};
	while (true) {
		old_PS := PS;
		PS := eliminateCycles(PS + oneStep(PS, R));
		P := {p in PS | p(#p) == y};
		if (P != {}) {
			return arb(P);
		}
		if (old_PS == PS) {
			return;
		}
	}
};

All := {1, 2, 3};
P := {[S1, S2, S3]: S1 in pow(All), S2 in pow(All), S3 in pow(All) | partition(S1, S2, S3, All)};
print("P = ", P);
R := +/ {relation(P, i, j): i in {1, 2, 3}, j in {1, 2, 3} | i != j};
print("R:");
for ([x, y] in R) {
	print(x, "  ->   ", y);
}
print();
start := [{1, 2, 3}, {}, {}];
goal := [{2}, {1}, {3}];
path := reachable(start, goal, R);
printPath(path);

