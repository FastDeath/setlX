
parse := procedure(s) {
	mTokenList := scanFormula(s);
	mIndex := 1;
	result := parseFormula();
	print(result);
	print(prettyPrint(result));
	return normalize(result);
};

parseFormula := procedure() {
	implicationLhs := parseImplication();
	if (mIndex <= #mTokenList && mTokenList(mIndex) != ")") {
		check("<->");
		implicationRhs := parseImplication();
		return [implicationLhs, "<->", implicationRhs];
	} else {
		return implicationLhs;
	}
};

parseImplication := procedure() {
	conjunction := parseConjunction();
	if (mIndex <= #mTokenList && mTokenList(mIndex) notin {"<->", ")"}) {
		check("->");
		implication := parseImplication();
		return [conjunction, "->", implication];
	} else {
		return conjunction;
	}
};

parseConjunction := procedure() {
	disjunction := parseDisjunction();
	return parseConjunctionRest(disjunction);
};

parseConjunctionRest := procedure(formula) {
	if (check("*")) {
		disjunction := parseDisjunction();
		return parseConjunctionRest([formula, "*", disjunction]);
	}
	return formula;
};

parseDisjunction := procedure() {
	negation := parseNegation();
	return parseDisjunctionRest(negation);
};

parseDisjunctionRest := procedure(formula) {
	if (check("+")) {
		negation := parseNegation();
		return parseDisjunctionRest([formula, "+", negation]);
	}
	return formula;
};

parseNegation := procedure() {
	if (check("-")) {
		negation := parseNegation();
		return ["-", negation];
	}
	return parseAtomic();
};

parseAtomic := procedure() {
	if (check("(")) {
		formula := parseFormula();
		if (! (check(")"))) {
			abort("Parse Error, ')' expected");
		}
		return formula;
	}
	if (isString((mTokenList(mIndex)))) {
		result := mTokenList(mIndex);
		mIndex := mIndex + 1;
		return result;
	}
	abort("Parse Error in parseFactor,");
};

check := procedure(token) {
	if (mIndex > #mTokenList) {
		return false;
	}
	if (mTokenList(mIndex) == token) {
		mIndex := mIndex + 1;
		return true;
	}
	return false;
};

scanFormula := procedure(s) {
	letters := {};
	for (x in {48 .. 57} + {65 .. 90} + {97 .. 122}) {
		letters := letters + {char((x))};
	}
	switch {
		case s == "" :
			return [];
		case s(1) == "(" :
			return ["("] + scanFormula(s(2..));
		case s(1) == ")" :
			return [")"] + scanFormula(s(2..));
		case s(1) == "+" :
			return ["+"] + scanFormula(s(2..));
		case s(1) == "*" :
			return ["*"] + scanFormula(s(2..));
		case #s >= 2 && s(1..2) == "->" :
			return ["->"] + scanFormula(s(3..));
		case #s >= 3 && s(1..3) == "<->" :
			return ["<->"] + scanFormula(s(4..));
		case s(1) == "-" :
			return ["-"] + scanFormula(s(2..));
		case s(1) == " " || s(1) == "    " :
			return scanFormula(s(2..));
	}
	index := 1;
	word := "";
	if (s(index) notin letters) {
		abort("Error in scanFormula(" + s + ")");
	}
	while (s(index) in letters && index < #s) {
		index := index + 1;
	}
	if (! (s(index) in letters)) {
		return [s(1..index - 1)] + scanFormula(s(index..));
	}
	if (index == #s) {
		return [s];
	}
	print("Error in scanFormula: s = ", s);
};

prettyPrint := procedure(f) {
	switch {
		case f == 1 :
			return "1";
		case f == 0 :
			return "0";
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return "-" + prettyPrint(f(2));
		case f(2) == "*" :
			return "(" + prettyPrint(f(1)) + " * " + prettyPrint(f(3)) + ")";
		case f(2) == "+" :
			return "(" + prettyPrint(f(1)) + " + " + prettyPrint(f(3)) + ")";
		case f(2) == "->" :
			return "(" + prettyPrint(f(1)) + " -> " + prettyPrint(f(3)) + ")";
		case f(2) == "<->" :
			return "(" + prettyPrint(f(1)) + " <-> " + prettyPrint(f(3)) + ")";
		default :
			abort("Error in prettyPrint: " + str((f)));
	}
};

DavisPutnam := procedure(Clauses, Literals) {
	Clauses := saturate(Clauses);
	if ({} in Clauses) {
		return false;
	}
	if ({k in Clauses | #k == 1} == Clauses) {
		return Clauses;
	}
	literal := selectLiteral(Clauses, Literals);
	Result := DavisPutnam(Clauses + {{literal}}, Literals + {literal});
	if (Result != false) {
		return Result;
	}
	notLiteral := negateLiteral(literal);
	return DavisPutnam(Clauses + {{notLiteral}}, Literals + {notliteral});
};

saturate := procedure(S) {
	Units := {k in S | #k == 1};
	Used := {};
	while (Units != {}) {
		unit := arb(Units);
		Used := Used + {unit};
		literal := arb(unit);
		S := reduce(S, literal);
		Units := {k in S | #k == 1} - Used;
	}
	return S;
};

reduce := procedure(S, l) {
	notL := negateLiteral(l);
	return {k - {notL}: k in S | notL in k} + {k in S | ! (notL in k) && ! (l in k)} + {{l}};
};

selectLiteral := procedure(S, Forbidden) {
	return arb({l: k in S, l in k | ! (l in Forbidden)});
};

negateLiteral := procedure(l) {
	if (l(1) == "-") {
		return l(2);
	} else {
		return ["-", l];
	}
};

normalize := procedure(f) {
	n1 := elimGdw(f);
	n2 := elimFolgt(n1);
	n3 := nnf(n2);
	n4 := knf(n3);
	return n4;
};

elimGdw := procedure(f) {
	switch {
		case f == 1 :
			return 1;
		case f == 0 :
			return 0;
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return ["-", elimGdw(f(2))];
		case f(2) == "*" :
			return [elimGdw(f(1)), "*", elimGdw(f(3))];
		case f(2) == "+" :
			return [elimGdw(f(1)), "+", elimGdw(f(3))];
		case f(2) == "->" :
			return [elimGdw(f(1)), "->", elimGdw(f(3))];
		case f(2) == "<->" :
			return elimGdw([[f(1), "->", f(3)], "*", [f(3), "->", f(1)]]);
		default :
			print("Fehler in elimGdw( ", f, ")");
	}
};

elimFolgt := procedure(f) {
	switch {
		case f == 1 :
			return 1;
		case f == 0 :
			return 0;
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return ["-", elimFolgt(f(2))];
		case f(2) == "*" :
			return [elimFolgt(f(1)), "*", elimFolgt(f(3))];
		case f(2) == "+" :
			return [elimFolgt(f(1)), "+", elimFolgt(f(3))];
		case f(2) == "->" :
			return elimFolgt([["-", f(1)], "+", f(3)]);
		default :
			print("Fehler in elimFolgt( ", f, ")");
	}
};

nnf := procedure(f) {
	switch {
		case f == 1 :
			return 1;
		case f == 0 :
			return 0;
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return neg(f(2));
		case f(2) == "*" :
			return [nnf(f(1)), "*", nnf(f(3))];
		case f(2) == "+" :
			return [nnf(f(1)), "+", nnf(f(3))];
		default :
			print("Fehler in nnf( ", f, ")");
	}
};

neg := procedure(f) {
	switch {
		case f == 1 :
			return 0;
		case f == 0 :
			return 1;
		case isString((f)) :
			return ["-", f];
		case f(1) == "-" :
			return nnf(f(2));
		case f(2) == "*" :
			return [neg(f(1)), "+", neg(f(3))];
		case f(2) == "+" :
			return [neg(f(1)), "*", neg(f(3))];
		default :
			print("Fehler in neg( ", f, ")");
	}
};

knf := procedure(f) {
	switch {
		case f == 1 :
			return {};
		case f == 0 :
			return {{}};
		case isString((f)) :
			return {{f}};
		case f(1) == "-" :
			return {{f}};
		case f(2) == "*" :
			return knf(f(1)) + knf(f(3));
		case f(2) == "+" :
			return {k1 + k2: k1 in knf(f(1)), k2 in knf(f(3))};
		default :
			print("Fehler in knf( ", f, ")");
	}
};

var mTokenList;
var mIndex;
f0 := parse("p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9");
f1 := parse("p1 -> -(p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9)");
f2 := parse("p2 -> -(p1 + p3 + p4 + p5 + p6 + p7 + p8 + p9)");
f3 := parse("p3 -> -(p1 + p2 + p4 + p5 + p6 + p7 + p8 + p9)");
f4 := parse("p4 -> -(p1 + p2 + p3 + p5 + p6 + p7 + p8 + p9)");
f5 := parse("p5 -> -(p1 + p2 + p3 + p4 + p6 + p7 + p8 + p9)");
f6 := parse("p6 -> -(p1 + p2 + p3 + p4 + p5 + p7 + p8 + p9)");
f7 := parse("p7 -> -(p1 + p2 + p3 + p4 + p5 + p6 + p8 + p9)");
f8 := parse("p8 -> -(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p9)");
f9 := parse("p9 -> -(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8)");
f10 := parse("p1 -> r1");
f11 := parse("p2 -> r2");
f12 := parse("p3 -> r3");
f13 := parse("p4 -> r4");
f14 := parse("p5 -> r5");
f15 := parse("p6 -> r6");
f16 := parse("p7 -> r7");
f17 := parse("p8 -> r8");
f18 := parse("p9 -> r9");
f19 := parse("t1 -> -r1");
f20 := parse("t2 -> -r2");
f21 := parse("t3 -> -r3");
f22 := parse("t4 -> -r4");
f23 := parse("t5 -> -r5");
f24 := parse("t6 -> -r6");
f25 := parse("t7 -> -r7");
f26 := parse("t8 -> -r8");
f27 := parse("t9 -> -r9");
f28 := parse("r1 <-> (p1 + p3 + p5 + p7 + p9) * -t2 * -t4 * -t6 * -t8");
f29 := parse("r2 <-> -p2 * -t2");
f30 := parse("r3 <-> r5 * -r7 * t3");
f31 := parse("r4 <-> -r1 * -t8 * r9");
f32 := parse("r5 <-> (r2 + r4) -> -t1");
f33 := parse("r6 <-> -r3 * p2 * -t4");
f34 := parse("r7 <-> p1 * r5");
f35 := parse("r8 <-> -t8 * -p9 * -t9");
f36 := parse("r9 <-> -t9 * -t1 * r6");
f37 := parse("-p1 * -t1 -> (r1 <-> e)");
f38 := parse("-p2 * -t2 -> (r2 <-> e)");
f39 := parse("-p3 * -t3 -> (r3 <-> e)");
f40 := parse("-p4 * -t4 -> (r4 <-> e)");
f41 := parse("-p5 * -t5 -> (r5 <-> e)");
f42 := parse("-p6 * -t6 -> (r6 <-> e)");
f43 := parse("-p7 * -t7 -> (r7 <-> e)");
f44 := parse("-p8 * -t8 -> (r8 <-> e)");
f45 := parse("-p9 * -t9 -> (r9 <-> e)");
Clauses := +/ {f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23, f24, f25, f26, f27, f28, f29, f30, f31, f32, f33, f34, f35, f36, f37, f38, f39, f40, f41, f42, f43, f44, f45};
for (x in {"p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9"}) {
	if (DavisPutnam(Clauses + {{x}}, {}) != false) {
		print("The princess is in room ", x, ".");
	}
}
for (x in {"t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9"}) {
	if (DavisPutnam(Clauses + {{x}}, {}) != false) {
		print("A tiger might be in room ", x, ".");
	}
}
solution := DavisPutnam(Clauses, {});
print(solution);

