
reachable := procedure(x, y, r) {
	p := {[x]};
	while (true) {
		old_P := p;
		p := path_product(p, r);
		print("#P = ", #p, " length = ", max({#l: l in p}));
		print("#P = ", #p);
		found := {p in p | p(1) == x && p(#p) == y};
		if (found != {}) {
			return arb(found);
		}
		if (p == old_P) {
			return;
		}
	}
};

path_product := procedure(p, q) {
	return {add(p, q): p in p, q in q | p(#p) == q(1) && ( ! (cyclic(add(p, q))) )};
};

cyclic := procedure(p) {
	return #{x: x in p} < #p;
};

add := procedure(p, q) {
	return p + q(2..);
};

toList := procedure(s) {
	if (s == {}) {
		return {[]};
	}
	return {[x] + l: x in s, l in toList(s - {x})};
};

reverse := procedure(l) {
	n := #l;
	return [l(n - i): i in {0 .. n - 1}];
};

inverse := procedure(r) {
	return {[y, x]: [x, y] in r};
};

printPath := procedure(path) {
	print("Solution:\n");
	for ([a, b, c] in path) {
		printState(a, b, c);
	}
};

printState := procedure(a, b, c) {
	print("A: ", a, "; B: ", b, "; C: ", c);
};

all := {0 .. 3};
partitions := {[a, b, c]: a in pow(all), b in pow(all), c in pow(all) | a * b == {} && a * c == {} && b * c == {} && a + b + c == all};
print(#partitions);
p := {[lA, lB, lC]: [a, b, c] in partitions, lA in toList(a), lB in toList(b), lC in toList(c)};
print(#p);
rACeast := {[[a, b, c], [a(1..k - 1), b, c + reverse(a(k..))]]: [a, b, c] in p, k in {1 .. #a} | 0 in a(k..)};
print(#rACeast);
rACwest := {[[a, b, c], [a(k + 1..), b, reverse(a(1..k)) + c]]: [a, b, c] in p, k in {1 .. #a} | 0 in a(1..k)};
print(#rACwest);
rAC := rACeast + rACwest;
rCA := inverse(rAC);
rBC := {[[a, b, c], [a, b(1..k - 1), b(k..) + c]]: [a, b, c] in p, k in {1 .. #b} | 0 in b(k..)};
rCB := inverse(rBC);
r := rAC + rCA + rBC + rCB;
print("#R = ", #r);
start := [[1, 2, 3], [0], []];
goal := [[], [0], [3, 1, 2]];
path := reachable(start, goal, r);
printPath(path);

