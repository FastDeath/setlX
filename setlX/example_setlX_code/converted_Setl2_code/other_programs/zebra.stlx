
onePerHouse := procedure(M) {
	return {somewhere(x): x in M} + {something(M, i): i in {1 .. 5}} + +/ {atMostOneAt(M, i): i in {1 .. 5}};
};

somewhere := procedure(x) {
	return {x + i: i in {1 .. 5}};
};

something := procedure(M, i) {
	return {x + i: x in M};
};

atMostOneAt := procedure(M, i) {
	return atMostOne({x + i: x in M});
};

atMostOne := procedure(S) {
	return {{["-", p], ["-", q]}: p in S, q in S | p != q};
};

nextTo := procedure(a, b) {
	F := parse(a + "1 -> " + b + "2");
	for (i in {2 .. 4}) {
		F := F + parse(a + i + " -> " + b + (i - 1) + " + " + b + (i + 1));
	}
	F := F + parse(a + "5 -> " + b + "4");
	return F;
};

leftTo := procedure(x, y) {
	F := {};
	for (i in {1 .. 4}) {
		F := F + parse(x + i + " -> " + y + (i + 1));
	}
	F := F + parse("-" + x + "5");
	return F;
};

printSolution := procedure(S) {
	for (c in S) {
		l := arb(c);
		if (l(1) != "-") {
			print(l);
		}
	}
};

parse := procedure(s) {
	mTokenList := scanFormula(s);
	mIndex := 1;
	result := parseFormula();
	return normalize(result);
};

parseFormula := procedure() {
	implicationLhs := parseImplication();
	if (mIndex <= #mTokenList && mTokenList(mIndex) != ")") {
		check("<->");
		implicationRhs := parseImplication();
		return [implicationLhs, "<->", implicationRhs];
	} else {
		return implicationLhs;
	}
};

parseImplication := procedure() {
	conjunction := parseConjunction();
	if (mIndex <= #mTokenList && mTokenList(mIndex) notin {"<->", ")"}) {
		check("->");
		implication := parseImplication();
		return [conjunction, "->", implication];
	} else {
		return conjunction;
	}
};

parseConjunction := procedure() {
	disjunction := parseDisjunction();
	return parseConjunctionRest(disjunction);
};

parseConjunctionRest := procedure(formula) {
	if (check("*")) {
		disjunction := parseDisjunction();
		return parseConjunctionRest([formula, "*", disjunction]);
	}
	return formula;
};

parseDisjunction := procedure() {
	negation := parseNegation();
	return parseDisjunctionRest(negation);
};

parseDisjunctionRest := procedure(formula) {
	if (check("+")) {
		negation := parseNegation();
		return parseDisjunctionRest([formula, "+", negation]);
	}
	return formula;
};

parseNegation := procedure() {
	if (check("-")) {
		negation := parseNegation();
		return ["-", negation];
	}
	return parseAtomic();
};

parseAtomic := procedure() {
	if (check("(")) {
		formula := parseFormula();
		if (! (check(")"))) {
			abort("Parse Error, ')' expected");
		}
		return formula;
	}
	if (isString((mTokenList(mIndex)))) {
		result := mTokenList(mIndex);
		mIndex := mIndex + 1;
		return result;
	}
	print(mTokenList);
	print(mIndex);
	abort("Parse Error in parseFactor. ");
};

check := procedure(token) {
	if (mIndex > #mTokenList) {
		return false;
	}
	if (mTokenList(mIndex) == token) {
		mIndex := mIndex + 1;
		return true;
	}
	return false;
};

scanFormula := procedure(s) {
	letters := {};
	for (x in {48 .. 57} + {65 .. 90} + {97 .. 122}) {
		letters := letters + {char((x))};
	}
	switch {
		case s == "" :
			return [];
		case s(1) == "0" :
			return ["0"] + scanFormula(s(2..));
		case s(1) == "1" :
			return ["1"] + scanFormula(s(2..));
		case s(1) == "(" :
			return ["("] + scanFormula(s(2..));
		case s(1) == ")" :
			return [")"] + scanFormula(s(2..));
		case s(1) == "+" :
			return ["+"] + scanFormula(s(2..));
		case s(1) == "*" :
			return ["*"] + scanFormula(s(2..));
		case #s >= 2 && s(1..2) == "->" :
			return ["->"] + scanFormula(s(3..));
		case #s >= 3 && s(1..3) == "<->" :
			return ["<->"] + scanFormula(s(4..));
		case s(1) == "-" :
			return ["-"] + scanFormula(s(2..));
		case s(1) == " " || s(1) == "    " :
			return scanFormula(s(2..));
	}
	index := 1;
	word := "";
	if (s(index) notin letters) {
		abort("Error in scanFormula(" + s + ")");
	}
	while (s(index) in letters && index < #s) {
		index := index + 1;
	}
	if (! (s(index) in letters)) {
		return [s(1..index - 1)] + scanFormula(s(index..));
	}
	if (index == #s) {
		return [s];
	}
	print("Error in scanFormula: s = ", s);
};

prettyPrint := procedure(f) {
	switch {
		case f == 1 :
			return "1";
		case f == 0 :
			return "0";
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return "-" + prettyPrint(f(2));
		case f(2) == "*" :
			return "(" + prettyPrint(f(1)) + " * " + prettyPrint(f(3)) + ")";
		case f(2) == "+" :
			return "(" + prettyPrint(f(1)) + " + " + prettyPrint(f(3)) + ")";
		case f(2) == "->" :
			return "(" + prettyPrint(f(1)) + " -> " + prettyPrint(f(3)) + ")";
		case f(2) == "<->" :
			return "(" + prettyPrint(f(1)) + " <-> " + prettyPrint(f(3)) + ")";
		default :
			abort("Error in prettyPrint: " + str((f)));
	}
};

DavisPutnam := procedure(Clauses, Literals) {
	Clauses := saturate(Clauses);
	if ({} in Clauses) {
		return false;
	}
	if ({k in Clauses | #k == 1} == Clauses) {
		return Clauses;
	}
	literal := selectLiteral(Clauses, Literals);
	Result := DavisPutnam(Clauses + {{literal}}, Literals + {literal});
	if (Result != false) {
		return Result;
	}
	notLiteral := negateLiteral(literal);
	return DavisPutnam(Clauses + {{notLiteral}}, Literals + {notliteral});
};

saturate := procedure(S) {
	Units := {k in S | #k == 1};
	Used := {};
	while (Units != {}) {
		unit := arb(Units);
		Used := Used + {unit};
		literal := arb(unit);
		S := reduce(S, literal);
		Units := {k in S | #k == 1} - Used;
	}
	return S;
};

reduce := procedure(S, l) {
	notL := negateLiteral(l);
	return {k - {notL}: k in S | notL in k} + {k in S | ! (notL in k) && ! (l in k)} + {{l}};
};

selectLiteral := procedure(S, Forbidden) {
	return arb({l: k in S, l in k | ! (l in Forbidden)});
};

negateLiteral := procedure(l) {
	if (l(1) == "-") {
		return l(2);
	} else {
		return ["-", l];
	}
};

normalize := procedure(f) {
	n1 := elimGdw(f);
	n2 := elimFolgt(n1);
	n3 := nnf(n2);
	n4 := knf(n3);
	return n4;
};

elimGdw := procedure(f) {
	switch {
		case f == "1" :
			return "1";
		case f == "0" :
			return "0";
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return ["-", elimGdw(f(2))];
		case f(2) == "*" :
			return [elimGdw(f(1)), "*", elimGdw(f(3))];
		case f(2) == "+" :
			return [elimGdw(f(1)), "+", elimGdw(f(3))];
		case f(2) == "->" :
			return [elimGdw(f(1)), "->", elimGdw(f(3))];
		case f(2) == "<->" :
			return elimGdw([[f(1), "->", f(3)], "*", [f(3), "->", f(1)]]);
		default :
			print("Fehler in elimGdw( ", f, ")");
	}
};

elimFolgt := procedure(f) {
	switch {
		case f == "1" :
			return "1";
		case f == "0" :
			return "0";
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return ["-", elimFolgt(f(2))];
		case f(2) == "*" :
			return [elimFolgt(f(1)), "*", elimFolgt(f(3))];
		case f(2) == "+" :
			return [elimFolgt(f(1)), "+", elimFolgt(f(3))];
		case f(2) == "->" :
			return elimFolgt([["-", f(1)], "+", f(3)]);
		default :
			print("Fehler in elimFolgt( ", f, ")");
	}
};

nnf := procedure(f) {
	switch {
		case f == "1" :
			return "1";
		case f == "0" :
			return "0";
		case isString((f)) :
			return f;
		case f(1) == "-" :
			return neg(f(2));
		case f(2) == "*" :
			return [nnf(f(1)), "*", nnf(f(3))];
		case f(2) == "+" :
			return [nnf(f(1)), "+", nnf(f(3))];
		default :
			print("Fehler in nnf( ", f, ")");
	}
};

neg := procedure(f) {
	switch {
		case f == "1" :
			return "0";
		case f == "0" :
			return "1";
		case isString((f)) :
			return ["-", f];
		case f(1) == "-" :
			return nnf(f(2));
		case f(2) == "*" :
			return [neg(f(1)), "+", neg(f(3))];
		case f(2) == "+" :
			return [neg(f(1)), "*", neg(f(3))];
		default :
			print("Fehler in neg( ", f, ")");
	}
};

knf := procedure(f) {
	switch {
		case f == "1" :
			return {};
		case f == "0" :
			return {{}};
		case isString((f)) :
			return {{f}};
		case f(1) == "-" :
			return {{f}};
		case f(2) == "*" :
			return knf(f(1)) + knf(f(3));
		case f(2) == "+" :
			return {k1 + k2: k1 in knf(f(1)), k2 in knf(f(3))};
		default :
			print("Fehler in knf( ", f, ")");
	}
};

var mTokenList;
var mIndex;
German := "German";
Briton := "Briton";
Swede := "Swede";
American := "American";
Norwegian := "Norwegian";
Red := "red";
Green := "green";
White := "white";
Blue := "blue";
Yellow := "yellow";
PallMall := "PallMall";
Dunhill := "Dunhill";
Marlboro := "Marlboro";
Winfield := "Winfield";
Rothmanns := "Rothmanns";
Dog := "dog";
Bird := "bird";
Cat := "cat";
Pig := "pig";
Zebra := "zebra";
Whiskey := "whiskey";
Coffee := "coffee";
Beer := "beer";
Milk := "milk";
Water := "water";
F := {};
F := F + onePerHouse({German, Briton, Swede, American, Norwegian});
F := F + onePerHouse({Red, Green, White, Blue, Yellow});
F := F + onePerHouse({PallMall, Dunhill, Marlboro, Winfield, Rothmanns});
F := F + onePerHouse({Dog, Bird, Cat, Pig, Zebra});
F := F + onePerHouse({Whiskey, Coffee, Beer, Milk, Water});
for (i in {1 .. 5}) {
	F := F + parse(Briton + i + " -> " + Red + i);
	F := F + parse(Swede + i + " -> " + Dog + i);
	F := F + parse(American + i + " -> " + Whiskey + i);
	F := F + parse(Green + i + " -> " + Coffee + i);
	F := F + parse(PallMall + i + " -> " + Bird + i);
	F := F + parse(Yellow + i + " -> " + Dunhill + i);
	F := F + parse(Winfield + i + " -> " + Beer + i);
	F := F + parse(German + i + " -> " + Rothmanns + i);
}
print(F);
F := F + leftTo(Green, White);
F := F + parse(Milk + 3);
F := F + parse(Norwegian + 1);
F := F + nextTo(Marlboro, Cat);
F := F + nextTo(Pig, Dunhill);
F := F + nextTo(Norwegian, Blue);
F := F + nextTo(Marlboro, Water);
S := DavisPutnam(F, {});
printSolution(S);
print("checking uniqueness ...");
for (i in {1 .. 5}) {
	S := DavisPutnam(F + parse(Zebra + i), {});
	if (S == false) {
		print("The zebra cannot be in house number " + i + ".");
	} else {
		print("The zebra might be in house number " + i + ".");
		printSolution(S);
	}
}

