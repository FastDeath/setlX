
problem := procedure(m, k) {
	linkesUferProblem := m != 0 && (m < k);
	rechtesUferProblem := m != 3 && ((3 - m) < (3 - k));
	return linkesUferProblem || rechtesUferProblem;
};

printPath := procedure(path) {
	print("L�sung:\n");
	for (i in {1 .. #path - 1}) {
		[m1, k1, b1] := path(i);
		[m2, k2, b2] := path(i + 1);
		printState(m1, k1, b1);
		printBoat(m1, k1, b1, m2, k2, b2);
	}
	[m, k, b] := path(#path);
	printState(m, k, b);
};

printState := procedure(m, k, b) {
	print(fillCharsRight(m * "M", 6) + fillCharsRight(k * "K", 6) + fillCharsRight(b * "B", 3) + "    |~~~~~|    " + fillCharsLeft((3 - m) * "M", 6) + fillCharsLeft((3 - k) * "K", 6) + fillCharsLeft((1 - b) * "B", 3));
};

printBoat := procedure(m1, k1, b1, m2, k2, b2) {
	if (b1 == 1) {
		if (m1 < m2) {
			print("Fehler in printBoat: negative Anzahl von Missionaren im Boot!");
		}
		if (k1 < k2) {
			print("Fehler in printBoat: negative Anzahl von Kannibalen im Boot!");
		}
		print(19 * " " + "> " + fillCharsBoth((m1 - m2) * "M" + " " + (k1 - k2) * "K", 3) + " >");
	} else {
		if (m1 > m2) {
			print("Fehler in printBoat: negative Anzahl von Missionaren im Boot!");
		}
		if (k1 > k2) {
			print("Fehler in printBoat: negative Anzahl von Kannibalen im Boot!");
		}
		print(19 * " " + "< " + fillCharsBoth((m2 - m1) * "M" + " " + (k2 - k1) * "K", 3) + " <");
	}
};

fillCharsLeft := procedure(x, n) {
	s := str((x));
	m := n - #s;
	return m * " " + s;
};

fillCharsRight := procedure(x, n) {
	s := str((x));
	m := n - #s;
	return s + m * " ";
};

fillCharsBoth := procedure(x, n) {
	s := str((x));
	ml := (n - #s) / 2;
	mr := (n + 1 - #s) / 2;
	return ml * " " + s + mr * " ";
};

reachable := procedure(x, y, r) {
	p := {[x]};
	while (true) {
		old_P := p;
		p := p + path_product(p, r);
		found := {p in p | p(#p) == y};
		if (found != {}) {
			return arb(found);
		}
		if (p == old_P) {
			return;
		}
	}
};

path_product := procedure(p, q) {
	return {add(p, q): p in p, q in q | p(#p) == q(1) && not_cyclic(add(p, q))};
};

not_cyclic := procedure(p) {
	return #{x: x in p} == #p;
};

add := procedure(p, q) {
	return p + q(2..);
};

p := {[m, k, b]: m in {0 .. 3}, k in {0 .. 3}, b in {0 .. 1} | ( ! (problem(m, k)) )};
print("M�gliche Zust�nde:\n");
for ([m, k, b] in p) {
	printState(m, k, b);
}
print("\n");
r1 := {[[m, k, 1], [m - mB, k - kB, 0]]: [m, k, b] in p, mB in {0 .. m}, kB in {0 .. k} | (mB + kB <= 2) && (mB + kB > 0) && ( ! (problem(m - mB, k - kB)) )};
print("R1:\n");
for ([[m1, k1, b1], [m2, k2, b2]] in r1) {
	print();
	printState(m1, k1, b1);
	printBoat(m1, k1, b1, m2, k2, b2);
	printState(m2, k2, b2);
}
print("\n");
r2 := {[[m, k, 0], [m + mB, k + kB, 1]]: [m, k, b] in p, mB in {0 .. (3 - m)}, kB in {0 .. (3 - k)} | (mB + kB <= 2) && (mB + kB > 0) && ( ! (problem(m + mB, k + kB)) )};
print("R2:\n");
for ([[m1, k1, b1], [m2, k2, b2]] in r2) {
	print();
	printState(m1, k1, b1);
	printBoat(m1, k1, b1, m2, k2, b2);
	printState(m2, k2, b2);
}
print("\n");
r := r1 + r2;
start := [3, 3, 1];
goal := [0, 0, 0];
path := reachable(start, goal, r);
printPath(path);

