// this program demonstrates the parser and eval functionality, and is rigged to not require user input

var inputA;
var inputB;

inputA := ["%x","x","5"];
inputB := ["%x","value + value","value ** value"];

getInput := procedure() {
    getValue := procedure() {
        print("Please enter some SetlX value");
        try {
            return eval(/*get()*/ fromB(inputA));
        } catch (error) {
            print();
            print("Oh... you did that wrong... try again!");
            print();
            return getValue();
        }
    };

    value := getValue();
    print("value\t:= $value$");
    print();

    getExpr := procedure() {
        print("Please enter some SetlX expression using the 'value' variable");
        try {
            expr:= parse(/*get()*/ fromB(inputB));
            if (! isTerm(expr) || 'variable("value") notin expr) {
                throw("wrong!");
            }
            return expr;
        } catch (error) {
            print();
            print("Oh... you did that wrong... try again!");
            print();
            return getExpr();
        }
    };

    expr := getExpr();
    print("expr\t:= " + expr);
    print("Syntax-Tree:\nexpr\t:= " + canonical(expr));
    print();

    try {
        return evalTerm(expr);
    } catch (error) {
        print();
        print("No, No, No... that did not work out!");
        print("Try again from the beginning, but don't make this error again:\n$error$");
        print();
        return getInput();
    }
};

result := getInput();
print("result\t:= $result$");
print();

print("Great result!");


