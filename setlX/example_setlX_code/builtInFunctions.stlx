// this program demonstrates some of the new and possibly interesting built-in functions

/*******************************************************************************
  mathConst(name)         // get the value of a mathematical constant (currently only pi and e)
*/

circumference := [r] |-> 2 * mathConst("pi") * r;
print("The circumference of a circle with radius 10 is: " + circumference(10) + ".");
print("100 is approximately " + log(mathConst("e") ** 100) + ".");
print();

/*******************************************************************************
  getScope()              // get a term representing all variables set in current scope
*/

print("variables in outer scope: ", canonical(getScope()));
printInnerScope := procedure() {
    secretVariable := 42;
    print("variables in inner scope: ", canonical(getScope()));
};
print("variables in outer scope: ", canonical(getScope()));
printInnerScope();
print("variables in outer scope: ", canonical(getScope()));
print();

/*******************************************************************************
  makeTerm(fnc, body)     // create a term with the form: fnc(body)
  fct(term)               // get functional char of a term
  args(term)              // get arguments of term
  canonical(term)         // returns a string of a term in its true form
*/

t := makeTerm("Arrr",["said","the","pirate"]);
a := str(args(t));
print(canonical(t));
print(fct(t), "(", a(2 .. #a-1), ")");
print();

/*******************************************************************************
  eval(expr)              // evaluate a string of a SetlX expression
  execute(stmnts)         // execute a string of SetlX statements
*/

execute("x := y := 6;");
print(eval("x ** y"), " == ", x ** y);
print();

/*******************************************************************************
  load(path)              // loads SetlX source code file and executes it
*/

load("../example_setlX_code/erlang.stlx"); // will fail if relative path is wrong...
print();

/*******************************************************************************
  int(stringOrNumber)     // convert string or number into an integer, returns om on failure
  real(stringOrNumber)    // convert string or number into a real, returns om on failure
  str(value)              // converts any value into a string, can not fail
*/

getIntRealOrStringFromInput := procedure(input) {
    testFunctions := [int, real, str];
    for (f in testFunctions) {
        result := f(input);
        if (result != om) {
            return result;
        }
    }
    // this should not be reached, because anything can be converted into a string...
    abort("Input can not be converted to integer, real or string!");
};

valueWithType := procedure(value) {
    switch {
        case isInteger(value): return "int    : " + value;
        case isReal(value)   : return "real   : " + value;
        case isString(value) : return "string : \"" + value + "\"";
        default              : return "??     : '"  + value + "'";
    }
};

userinput := ["99","text","text with number 5", "5.99", 6, 99.999, om, abs];
for (i in userinput) {
    print("direct:    ", valueWithType(i));
    print("converted: ", valueWithType(getIntRealOrStringFromInput(i)));
}
print();

/*******************************************************************************
  rnd(listOrSet);         // randomly select member from compound value; different from arb, as arb is deterministic and rnd is not
*/

throwACoin := [] |-> rnd({"heads", "tails"});
l := [];
for (i in [1 .. 100]) {
    l += [throwACoin()];
}
print(l); // will only be the same when interpreter is started with --predictableRandom
print();

/*******************************************************************************
  now()                   // get current time since epoch in ms
*/

daysSinceEpoch := procedure(ms) {
    aDayInMs := 1000 * 60 ** 2 * 24;
    return ms / aDayInMs;
};

// print(daysSinceEpoch(now()) + " days have gone by since 1970-01-01.");
// now make it testable...
print("When this was written, " + daysSinceEpoch(1325618124960) + " days had gone by since 1970-01-01.");
print();

/*******************************************************************************
  printErr(value, ...)    // same as print, but prints into stderr
*/
test := "test";
print   ( "This is a $test$");
print   (@"This is a $test$");
printErr( "This is a $test$");
printErr(@"This is a $test$");
print();

/*******************************************************************************
  getTerm(value)          // convert a value into a term
  parse(expr)             // parse string of a SetlX expression into a term
  parseStatements(stmnts) // parse string of SetlX statements into a term
*/
print("{throwACoin, print} = " + canonical(getTerm({throwACoin, print})));
print("a + 10 * b % 4 = " + canonical(parse("a + 10 * b % 4")));
print("\"print(parseStatements(\\\"print(\\\\\"that is crazy!\\\\\");\\\"));\" = " + canonical(parseStatements("print(parseStatements(\"print(\\\"that is crazy!\\\");\"));")));
print();

/*******************************************************************************
ToDo/Not jet implemented:

  evalTerm(term)          // execute a term which represents SetlX statements and/or expessions

*/
