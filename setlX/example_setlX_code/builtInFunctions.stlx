// this program demonstrates some of the new and possibly interesting built-in functions

/*******************************************************************************
mathConst(name)         // get the value of a mathematical constant (currently only pi and e)
*/

circumference := [r] |-> 2 * mathConst("pi") * r;
print("The circumference of a circle with radius 10 is: " + circumference(10) + ".");
print("100 is approximately " + log(mathConst("e") ** 100) + ".");
print();

/*******************************************************************************
getScope()              // get a term representing all variables set in current scope
*/

print("variables in outer scope: ", getScope());
printInnerScope := procedure() {
    secretVariable := 42;
    print("variables in inner scope: ", getScope());
};
print("variables in outer scope: ", getScope());
printInnerScope();
print("variables in outer scope: ", getScope());
print();

/*******************************************************************************
makeTerm(fnc, argList)  // create a term with the form: fnc(argList)
fct(term)               // get functional char of a term
args(term)              // get arguments of term
*/

t := makeTerm("Arrr",["said","the","pirate"]);
a := str(args(t));
print(t);
print(fct(t), "(", a(2 .. #a-1), ")");
print();

/*******************************************************************************
eval(expr)              // evaluate a String of a SetlX expression to a variable
execute(stmnts)         // execute a String of SetlX statements
*/

execute("x := y := 6;");
print(eval("x ** y"), " == ", x ** y);
print();

/*******************************************************************************
load(path)              // loads SetlX source code file and executes it
*/

load("../example_setlX_code/erlang.stlx"); // will fail if relative path is wrong...
print();

/*******************************************************************************
int(stringOrNumber)     // convert string or number into an integer, returns om on failure
real(stringOrNumber)    // convert string or number into a real, returns om on failure
str(value)              // converts any value into a string, can not fail
*/

getIntRealOrStringFromInput := procedure(input) {
    testFunctions := [int, real, str];
    for (f in testFunctions) {
        result := f(input);
        if (result != om) {
            return result;
        }
    }
    // this should not be reached, because anything can be converted into a string...
    abort("Input can not be converted to integer, real or string!");
};

valueWithType := procedure(value) {
    switch {
        case isInteger(value): return "int    : " + value;
        case isReal(value)   : return "real   : " + value;
        case isString(value) : return "string : \"" + value + "\"";
        default              : return "??     : '"  + value + "'";
    }
};

userinput := ["99","text","text with number 5", "5.99", 6, 99.999, om, abs];
for (i in userinput) {
    print("direct:    ", valueWithType(i));
    print("converted: ", valueWithType(getIntRealOrStringFromInput(i)));
}
print();

/*******************************************************************************
rnd(listOrSet);         // randomly select element from list or set; different from arb, as arb is deterministic
*/

throwACoin := [] |-> rnd({"heads", "tails"});
l := [];
for (i in [1 .. 100]) {
    l += [throwACoin()];
}
print(l); // will only be the same when interpreter is started with --predictableRandom
print();

/*******************************************************************************
now()                   // get current time since epoch in ms
*/

daysSinceEpoch := procedure(ms) {
    aDayInMs := 1000 * 60 ** 2 * 24;
    return ms / aDayInMs;
};

// print(daysSinceEpoch(now()) + " days have gone by since 1970-01-01.");
// now make it testable...
print("When this was written, " + daysSinceEpoch(1323062948018) + " days had gone by since 1970-01-01.");
print();

/*******************************************************************************
printDbg(value, ...)    // same as print, but does not interprete the string ($)
printErr(value, ...)    // same as print, but prints into stderr
printDbgErr(value, ...) // same as print, but does not interprete the string ($) and prints into stderr
*/
test := "test";
print("This is a $test$");
printDbg("This is a $test$");
printErr("This is a $test$");
printDbgErr("This is a $test$");
print();

/*******************************************************************************
ToDo/Not jet implemented:

evalTerm(term)          // execute terms which represent SetlX statements and expessions
getTerm(expr)           // convert the value of an expression into a term
parse(stmnts)           // parse SetlX statements into a term
parseExpr(expr)         // parse SetlX expression into a term

*/
