// this program demonstrates some of the new and possibly interesting built-in functions

/*******************************************************************************
  some math constants (not really a function)
*/

circumference := [r] |-> 2 * pi * r;
print("The circumference of a circle with radius 10 is: " + circumference(10) + ".");
print("100 is approximately " + log(e ** 100) + ".");
print();

/*******************************************************************************
  getScope()                    // get a term representing all variables set in current scope
*/

print("variables in outer scope: ", getScope());
printInnerScope := procedure() {
    secretVariable := 42;
    print("variables in inner scope: ", getScope());
};
print("variables in outer scope: ", getScope());
printInnerScope();
print("variables in outer scope: ", getScope());
print();

/*******************************************************************************
  makeTerm(fnc, body)           // create a term with the form: fnc(body)
  fct(term)                     // get functional char of a term
  args(term)                    // get arguments of term
  canonical(term)               // returns a string of a term in its true form
*/

t := makeTerm("Arrr",["said","the","pirate"]);
a := str(args(t));
print(canonical(t));
print(fct(t), "(", a[2 .. #a-1], ")");
print();

/*******************************************************************************
  eval(expr)                    // evaluate a string of a SetlX expression
  execute(stmnts [, output])    // execute a string of SetlX statements, if `output' is true results of statements are printed when in interactive mode
*/

execute("x := y := 6;");
print(eval("x ** y"), " == ", x ** y);
print();

/*******************************************************************************
  load(path [, output])         // loads SetlX source code file and executes it, if `output' is true results of statements are printed when in interactive mode
*/

load("../example_SetlX_code/erlang.stlx"); // will fail if relative path is wrong...
print();

/*******************************************************************************
  int(stringOrNumber)           // convert string or number into an integer, returns om on failure
  rational(stringOrNumber)      // convert string or number into a rational, returns om on failure
  real(stringOrNumber)          // convert string or number into a real, returns om on failure
  str(value)                    // converts any value into a string, can not fail
*/

getIntRealOrStringFromInput := procedure(input) {
    testFunctions := [int, rational, real, str];
    for (f in testFunctions) {
        result := f(input);
        if (result != om) {
            return result;
        }
    }
    // this should not be reached, because anything can be converted into a string...
    abort("Input can not be converted to integer, real or string!");
};

valueWithType := procedure(value) {
    switch {
        case isInteger(value)  : return "int      : " + value;
        case isRational(value) : return "rational : " + value;
        case isReal(value)     : return "real     : " + value;
        case isString(value)   : return "string   : \"" + value + "\"";
        default                : return "??       : '"  + value + "'";
    }
};

userinput := ["99","text","text with number 5", "5.99", 6, 99.999, om, abs, 1/3, "99/100"];
for (i in userinput) {
    print("direct:    ", valueWithType(i));
    print("converted: ", valueWithType(getIntRealOrStringFromInput(i)));
}
print();

/*******************************************************************************
  rnd(collectionValue);         // randomly selects a member from `collectionValue'; different from arb, as arb is deterministic and rnd is not
*/

throwACoin := [] |-> rnd({"heads", "tails"});
l := [];
for (i in [1 .. 100]) {
    l += [throwACoin()];
}
print(l); // will only be the same when interpreter is started with --predictableRandom
print();

/*******************************************************************************
  now()                         // get current time since epoch in ms
  sleep(time_in_ms)             // pause execution for a number of milliseconds
*/

daysSinceEpoch := procedure(ms) {
    aDayInMs := 1000 * 60 ** 2 * 24;
    return floor(ms / aDayInMs);
};

// print(daysSinceEpoch(now()) + " days have gone by since 1970-01-01.");
// now make it testable...
print("When this was written, " + daysSinceEpoch(1333372502020) + " days had gone by since 1970-01-01.");
print("Lets wait 500ms to commemorate this occasion.");
sleep(500);
print("OK, that's enough.");
print();

/*******************************************************************************
  printErr(value, ...)          // same as print, but prints into stderr
*/
test := "test";
print   ( "This is a $test$");
print   (@"This is a $test$");
printErr( "This is a $test$");
printErr(@"This is a $test$");
print();

/*******************************************************************************
  getTerm(value)                // convert a value into a term
  parse(expr)                   // parse string of a SetlX expression into a term
  parseStatements(stmnts)       // parse string of SetlX statements into a term
*/
print("{throwACoin, print} = " + canonical(getTerm({throwACoin, print})));
print("a + 10 * b % 4 = " + canonical(parse("a + 10 * b % 4")));
print("\"print(parseStatements(\\\"print(\\\\\"that is crazy!\\\\\");\\\"));\" = " + canonical(parseStatements("print(parseStatements(\"print(\\\"that is crazy!\\\");\"));")));
print();

/*******************************************************************************
  evalTerm(term [, output])     // execute a term which represents SetlX statements and/or expressions, if `output' is true results of statements are printed when in interactive mode
*/
print( evalTerm(parse("1 + 5")) ); // 6
evalTerm(parseStatements("print(\"foo\");a := 99 * 2;b:= sin(1);")); // prints foo and sets a, b
print(a); // 198
print(b); // ~0.84
print();

/*******************************************************************************
  permutations(collectionValue) // computes all permutations of the element in `collectionValue'
*/
print("All permutations of $[1,2,2,3]$ are $permutations([1,2,2,3])$.");
print();

/*******************************************************************************
  assert(condition , message)   // stop execution and display message, if condition evaluates to false
*/
foo := [1 .. 10];
assert(foo == [1,2,3,4,5,6,7,8,9], "foo is malformed"); // assertion will fail

/*******************************************************************************
  The following function can only be demonstrated in interactive mode:
  printAfterEval(toggle)        // configures output of results after each evaluation of an statement containing an expression
*/


